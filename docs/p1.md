# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

永彤 吴 wuyongtong@stu.pku.edu.cn

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.



## Alarm Clock

#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.

```
static struct list sleeping;     	// The list contains all sleeping threads.
static struct lock sleep_lock;      // The lock used to protect the sleeping list.


struct thread {
    int64_t wakeup_tick;         	// The tick when this thread should wake up (if it's sleeping now)
    
    // The semaphore (init and down when timer_sleep (), up when timer_interrupt ())
    struct semaphore sleep_sema;  	
    
    struct list_elem sleep_elem;	// Used by sleeping list
}
```



#### ALGORITHMS

>A2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.

1. Calculate and save the tick this thread should wake up
2. Initialize this thread's `sleep_sema` to 0.
3. Insert this thread into the list `sleeping` (under lock protection)
4. Call `down(&sleep_sema)` to wait timer interrupt handler to allow this thread to continue.



Timer Interrupt Handler is responsible to check all the threads in `sleeping` list. If `wakeup_time <= current_ticks` then up the corresponding semaphore to allow the thread's executing.



>A3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?

1. Create a list for sleeping threads, instead of going through all threads.
2. Calculate the wake up time in advance to avoid an extra plus instruction per thread checked.



#### SYNCHRONIZATION

>A4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?

All the data accessed is per thread data, except the `sleeping` list, which is protected by a global lock.



>A5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?

First I initialize the semaphore to 0, and then add this thread to `sleeping` list, which enables timer interrupt handler to `up` the semaphore. Whenever the semaphore is up, the `down` operation can correctly work.

#### RATIONALE

>A6: Why did you choose this design?  In what ways is it superior to
>another design you considered?

It's simple and effective. 

1. There is no extra dynamic memory allocation.
2. Although it need to going through all sleeping threads, I suppose threads always want to do something and there wont be a huge amount of threads to sleep together. 

3. I can implement it in tens of line, and a priority queue can be adopted without much code modification, if necessary.



## Priority Scheduling

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



>B2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>B3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>B4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>B5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>B6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>B7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>C2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>C3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>C4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?