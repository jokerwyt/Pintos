# Project 2: User Programs

## Preliminaries

>Fill in your name and email address.

永彤 吴 2100013022@stu.pku.edu.cn

>If you have any preliminary comments on your submission, notes for the TAs, please give them here.



>Please cite any offline or online sources you consulted while preparing your submission, other than the Pintos documentation, course text, lecture notes, and course staff.

google.com



## Argument Passing

#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.

No data structure is used to implement argument passing.

#### ALGORITHMS

>A2: Briefly describe how you implemented argument parsing.  How do you arrange for the elements of argv[] to be in the right order?
>How do you avoid overflowing the stack page?

**About how I implemented argument parsing.**

- Copy the command line to the top of user's stack.

- Split it into arguments with `strtok_r` .
- Construct argv[] and argc properly.

**About how I arrange elements of argv[]**

- I parse the arguments from left to right, and reverse the array.

**About how I avoid overflowing the stack page**

- I put a reasonable limit (256 bytes) on the command line's length passed to process_execute. So a page can contain all the things. (256 + 4 * count of space + 12, which will undoubtedly be less than 4K).

  

#### RATIONALE

>A3: Why does Pintos implement strtok_r() but not strtok()?

`strtok ()` is not thread safe. There are static variables in it.



>A4: In Pintos, the kernel separates commands into a executable name and arguments.  In Unix-like systems, the shell does this separation.  Identify at least two advantages of the Unix approach.

1. Because shell runs under user mode, it reduces the kernel's work and **avoids potential OS bugs** which bay guys could utilize.
2. It provides more **flexibility** for the shell to custom the arguments, without any modification to the kernel.



## System Calls

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.

```C
/* Global file system lock, shared by all threads */
struct lock fslock;


/* The struct for communication between parent and child */
struct exit_status
  {
    /* Used to notify the result of loading */
    struct semaphore loaded; // Up after load in start_process, down in process_exec.
    bool load_success;       // Be set before `loaded` up, 
                             // and then be read from process_exec

    struct lock mutex;      // mutex to protect the following shared data
    struct condition cond;  // cond to notify parent when child exits.

    /* shared between the parent and child */
    int exit_value;
    bool child_exited;
    bool parent_exited;    
    bool active_exited; // If the child thread calls exit (), 
                        // rather than terminated by the kernel.


    /* only accessed by parent */
    struct list_elem elem;
    tid_t child_id;
  };

/* Mapping file descriptors and the kernel's data structure */
struct proc_file
{
  struct file * file;
  int fd;

  struct list_elem elem;
};

@@ -97,6 +158,10 @@ struct thread
    struct exit_status *exit_info;		// the struct shared with this thread's parent
    struct list children_info;			// the list of its children's exit_info
    struct list opening_files;			// the lisf of all opening files, including the executable.
    int next_fd;						// next file descriptor to create (from 2 to INF_MAX, cyclic)
```



>B2: Describe how file descriptors are associated with open files. Are file descriptors unique within the entire OS or just within a single process?

An open system call will use `thread_current ()->next_fd` as the file descriptors to refer to the `struct file *`, and then increment `next_fd` cyclically.

File descriptors are unique just **within a single process.**



#### ALGORITHMS

>B3: Describe your code for reading and writing user data from the kernel.



Briefly, I directly **use the process's page directory** to validate a segment of user space address **page by page.** 

I describe my idea in detail with the following self-explained code.

```C
static void 
validate_page (uint32_t * pd, void * page, bool need_writable)
{
  uint32_t * p_pte = pagedir_lookup_pte (pd, page);
  // p_pte is the pointer to the page's pte.
    
  // Can't find x mapping in pd ----> Page fault
  if (p_pte == NULL || !pte_present (*p_pte))
      thread_exit ();
  
  if (need_writable && !pte_writable (*p_pte))
      thread_exit ();
}

static void 
validate_uaddr (void * _uaddr, size_t len, bool need_writable)
{  
  if (len == 0) return;

  uint8_t * uaddr = _uaddr; // just for convenience
  // Check the segment is entirely in user space. (<3G)
  if ((uint32_t)uaddr + len < 1 || is_kernel_vaddr (uaddr + len - 1)) 
      thread_exit ();

  uint32_t * pd = thread_current ()->pagedir;
  for (uint8_t * to_check = pg_round_down(uaddr); 
          to_check < uaddr + len; to_check += PGSIZE)	// check page by page
      validate_page (pd, to_check, need_writable);
}
```





>B4: Suppose a system call causes a full page (4,096 bytes) of data
>to be copied from user space into the kernel.  What is the least
>and the greatest possible number of inspections of the page table
>(e.g. calls to pagedir_get_page()) that might result?  What about
>for a system call that only copies 2 bytes of data?  Is there room
>for improvement in these numbers, and how much?

Case 1: it needs at least 1 or at most 4096 times inspections. It depends on how many pages include the data we need to read.

Case 2: at least 1, at most 2.





>B5: Briefly describe your implementation of the "wait" system call
>and how it interacts with process termination.



Every parent-child pair shares an exit_status struct, which contains all the data we need to synchronize them. If the parent doesn't wait for the child, then the last one who terminated handles freeing the resource.


For the `wait` system call: 

1. Check the children list and acquire the lock in the corresponding `exit_status`
2. Use condition variable `cond` to wait until `child_exited` becomes true.
3. Get the return value and free the struct.



When a process is terminated:

1. It acquires the lock
2. If `parent_exited=0`,  it'll set the return value, make `child_exited=1`, and signal `cond`.
3. else, it'll directly free the struct.

After that, the process terminated will also check all children's `exit_status`, to free space if necessary.


More detail lies in the struct `exit_status`'s block comment.



>B6: Any access to user program memory at a user-specified address
>can fail due to a bad pointer value.  Such accesses must cause the
>process to be terminated.  System calls are fraught with such
>accesses, e.g. a "write" system call requires reading the system
>call number from the user stack, then each of the call's three
>arguments, then an arbitrary amount of user memory, and any of
>these can fail at any point.  This poses a design and
>error-handling problem: how do you best avoid obscuring the primary
>function of code in a morass of error-handling?  Furthermore, when
>an error is detected, how do you ensure that all temporarily
>allocated resources (locks, buffers, etc.) are freed?  In a few
>paragraphs, describe the strategy or strategies you adopted for
>managing these issues.  Give an example.

1. **Encapsulate** all accesses to the user-given pointer into small functions, making the code look tidier.
2. Do all the validations **before** it holds **any** resources.
3. Free the resources **as soon, as near as possible.** 
4. **Check all returns and exits** carefully to see whether we have freed the resources.
5. **Avoid using return and exit directly.** Let the flow reach the end of the function.
6. **Clarify the ownership.** When multiple threads share the resource, there must be one who owns it and handles its free.

An example: 

```C
static void open_handler (struct intr_frame *f)
{
  // First of all, validate all input.
  // ARG do the validation.
  const char *name = (const char *) ARG (f, 1);  
  struct thread * cur = thread_current ();
  validate_str (name); // validate the whole string.
  
  // Acquire and release the lock as soon, as near as possible.
  lock_acquire (&fslock);
  struct file * file = filesys_open (name);
  lock_release (&fslock);

  if (file == NULL)
    set_ret (f, -1); // unsuccessfully
    // set the return value, but don't return immediately.
  else 
    {
      struct proc_file * pf = malloc (sizeof (struct proc_file));
      // pf needn't to be freed here.
      
      pf->file = file;
      pf->fd = cur->next_fd;
      if (cur->next_fd == INT32_MAX)
        cur->next_fd = MIN_FD;
      else
        cur->next_fd ++;
      list_push_front (&thread_current ()->opening_files, &pf->elem);
      set_ret (f, pf->fd);
    }
}
```



#### SYNCHRONIZATION

>B7: The "exec" system call returns -1 if loading the new executable
>fails, so it cannot return before the new executable has completed
>loading.  How does your code ensure this?  How is the load
>success/failure status passed back to the thread that calls "exec"?

Once the child knows about the loading result, it will set a bool variable in struct `exit_status` and up a semaphore. The exec system call will down this semaphore to wait for the result.



>B8: Consider parent process P with child process C.  How do you
>ensure proper synchronization and avoid race conditions when P
>calls wait(C) before C exits?  After C exits?  How do you ensure
>that all resources are freed in each case?  How about when P
>terminates without waiting, before C exits?  After C exits?  Are
>there any special cases?



I use a lock and a condition variable to ensure proper synchronization. To answer the question, I copy the struct `exit_status` block comment.

```C
/**
 * Shared by the parent and the child. 
 * The last event following is responsible for freeing resources.
 * 1. the child's process_exit
 * 2. the father's process_wait for the child,
 *    or the father's process_exit (if it has never waited for the child.)
 * 
 * Malloc and initialized at process_execute (),
 * Set exit_value at exit_handler ();
 * Free at process_exit () or process_wait ();
 * 
 * When the parent waits for the child:
 * 1. acquire the mutex
 * 2. until child_exited, do cond_wait ()
 * 3. get the value
 * 4. free resource
 * 
 * When the parent exit without the wait:
 * 1. acquire the mutex
 * 2. see child_exited
 * 3. if true, directly free the resource
 * 4. if false setup parent_exited
     * 5. release the mutex
 * 
 * When the child exits:
 * 1. acquire the mutex
 * 2. see parent_exited
 * 3. if true, directly free the resource
 * 4. if false, setup exit_value,
     * 5. and cond_signal ()
     * 6. release the mutex.
 */
```

There are no exceptional cases in the mechanism I designed. 



#### RATIONALE

>B9: Why did you choose to implement access to user memory from the
>kernel in the way that you did?

**High Efficiency**: validating the memory page by page is faster than validating in bytes.

**Simplicity**: Using the page directory to check the memory actively is simpler than catching a genuine page fault and is easier to implement.

**Readability**: the code is more understandable for programmers.



>B10: What advantages or disadvantages can you see to your design
>for file descriptors?

Advantages: 

- Simple, easy to design and check, straightforward
- There is nearly no limit on the number of opening files.
- Small numbers are better for human beings to read and debug.
- Security. Avoid exposure of the kernel data structure's address.

Disadvantages: 

- Low efficiency, it needs to go through the process's every opening file to get the file descriptors-files mapping.



>B11: The default tid_t to pid_t mapping is the identity mapping.
>If you changed it, what advantages are there to your approach?

I have kept it the same.